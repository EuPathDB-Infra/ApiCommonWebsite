#!/usr/bin/perl

use lib "$ENV{GUS_HOME}/lib/perl";

use strict;
use DBI;
use File::Basename;
use ApiCommonWebsite::Model::ModelConfig;
use IPC::Open2;

usage() unless scalar(@ARGV) == 7;

my ($outputFile, $geneResultSql, $modelName, $pValueCutoff, $subOntology, $sources, $evidCodes) = @ARGV;

die "First argument must be an SQL select statement that returns the Gene result\n" unless $geneResultSql =~ m/select/i;
die "Second argument must be a p-value between 0 and 1\n" unless $pValueCutoff > 0 && $pValueCutoff <= 1;

my $c = new ApiCommonWebsite::Model::ModelConfig($modelName);

my $dbh = DBI->connect($c->getAppDb->getDbiDsn, $c->getAppDb->getLogin, $c->getAppDb->getPassword) or die DBI::errstr;

my $taxonId = getTaxonId();

getEnrichment($dbh, $taxonId, $sources, $evidCodes, $geneResultSql);

$dbh->disconnect or warn "Disconnection failed: $DBI::errstr\n";

##############################################################################

sub getEnrichment {
  my ($dbh, $taxonId, $sources, $evidCodes, $geneResultSql) = @_;

  my $annotatedGenesBgd = getAnnotatedGenesCountBgd($dbh, $taxonId, $sources, $evidCodes);
  my $annotatedGenesResult = getAnnotatedGenesCountResult($dbh, $sources, $evidCodes, $geneResultSql);

  # get query to get back table to feed to python.
  # the columns are:  goId, bgdGeneCount, resultSetGeneCount
  my $dataSql = getDataSql($taxonId, $sources, $evidCodes, $geneResultSql);

  my $cmd = "enrichmentAnalysis $pValueCutoff $annotatedGenesBgd $annotatedGenesResult";

  local (*Reader, *Writer);
  my $pid = open2(\*Reader, \*Writer, $cmd);

  my $stmt = runSql($dbh, $dataSql);

  while ( my($goId, $geneCountBgd, $geneCountResult, $pctOfBgd, $goName) = $stmt->fetchrow_array()) {
#    print STDERR "$goId\t$geneCountBgd\t$geneCountResult\t$pctOfBgd\t$goName\n";
    print Writer "$goId\t$geneCountBgd\t$geneCountResult\t$pctOfBgd\t$goName\n";
  }

  close Writer;

  open(OUT, ">$outputFile") || die "Can't open '$outputFile' for writing\n";

  while(<Reader>) {
    chomp;
    my ($foldEnrichment, $oddsRatio, $percentOfResult, $pValue, $benjamini, $bonferroni, $termId, $bgdCount, $resultCount, $pctOfBgd, $goName) = split(/\t/);
    print OUT join("\t", $termId, $goName, $bgdCount, $resultCount, $pctOfBgd, $foldEnrichment, $oddsRatio, $pValue, $benjamini, $bonferroni) . "\n";
  }
  close Reader;
  waitpid($pid, 0);
  my $s = $? >> 8;
  die "Failed running command '$cmd'" if $s;
}

sub getTaxonId {
  my $sql = "
SELECT distinct ga.taxon_id
FROM  ApidbTuning.GeneAttributes ga,
     ($geneResultSql) r
where ga.source_id = r.source_id
";

  my $stmt = runSql($dbh, $sql);
  my $count = 0;
  my $taxonId;
  while (my ($taxId) = $stmt->fetchrow_array()) { $taxonId = $taxId; $count++; }
  die "Result has genes from more than one taxon\n" if $count != 1;
  return $taxonId;
}

sub getAnnotatedGenesCountBgd {
  my ($dbh, $taxonId, $sources, $evidCodes) = @_;

  my $sql = "
SELECT count(distinct ga.source_id)
FROM ApidbTuning.GoTermSummary gts, ApidbTuning.GeneAttributes ga
where ga.taxon_id = $taxonId
  and gts.source_id = ga.source_id
  and gts.is_not is null
  and gts.source in ($sources)
  and gts.evidence_code in ($evidCodes)
";

  my $stmt = runSql($dbh, $sql);
  my ($geneCount) = $stmt->fetchrow_array();
  die "Got null gene count for bgd annotated genes count\n" unless $geneCount;
  return $geneCount;
}

sub getAnnotatedGenesCountResult {
  my ($dbh, $sources, $evidCodes, $geneResultSql) = @_;

  my $sql = "
SELECT count(distinct gts.source_id)
FROM ApidbTuning.GoTermSummary gts,
     ($geneResultSql) r
where gts.source_id = r.source_id
  and gts.is_not is null
  and gts.source in ($sources)
  and gts.evidence_code in ($evidCodes)
";

  my $stmt = runSql($dbh, $sql);
  my ($geneCount) = $stmt->fetchrow_array();
  die "Got null gene count for result annotated genes count\n" unless $geneCount;
  return $geneCount;
}

sub getDataSql {
  my ($taxonId, $source, $evidCodes, $geneResultSql) = @_;

return "
select distinct bgd.go_id, bgdcnt, resultcnt, round(100*resultcnt/bgdcnt, 1) as pct_of_bgd, bgd.name
from
 (SELECT gt.go_id, count(distinct gts.source_id) as bgdcnt, gt.name
            FROM apidbtuning.geneattributes gf,
                 apidbtuning.gotermsummary gts,
                 sres.GoTerm gt,
                 sres.GoRelationship gr,
                 sres.GoRelationshipType grt
            WHERE gf.taxon_id = $taxonId
              AND gts.source_id = gf.source_id
              AND gts.ontology = '$subOntology'
              AND gts.source in ($sources)
              AND gts.evidence_code in ($evidCodes)
              AND gts.is_not is null
              AND gr.child_term_id = gts.go_term_id
              AND gt.go_term_id = gr.parent_term_id
              AND grt.go_relationship_type_id = gr.go_relationship_type_id
              AND grt.name = 'closure'
            group BY gt.go_id, gt.name
   ) bgd,
   (SELECT gt.go_id, count(distinct gts.source_id) as resultcnt
            FROM ApidbTuning.GoTermSummary gts,
                 sres.GoTerm gt,
                 sres.GoRelationship gr,
                 sres.GoRelationshipType grt,
                 ($geneResultSql) r
            WHERE gts.source_id = r.source_id
              AND gts.ontology = '$subOntology'
              AND gts.source in ($sources)
              AND gts.evidence_code in ($evidCodes)
              AND gts.is_not is null
              AND gr.child_term_id = gts.go_term_id
              AND gt.go_term_id = gr.parent_term_id
              AND gr.go_relationship_type_id = grt.go_relationship_type_id
              AND grt.name = 'closure'
            group BY gt.go_id
      ) rslt
where bgd.go_id = rslt.go_id
";
}

sub runSql {
  my ($dbh, $sql) = @_;
  # print STDERR "\n$sql\n\n";
  my $stmt = $dbh->prepare("$sql") or die(DBI::errstr);
  $stmt->execute() or die(DBI::errstr);
  return $stmt;
}

sub usage {
  my $this = basename($0);

  die "
Find GO terms that are enriched in the provided set of Genes.

Usage: $this sqlToFindGeneList pValueCutoff  outputFile subOntologyName modelName annotationSources evidenceCodes

Where:
  sqlToFindGeneList:    a select statement that will return all the rows in the db containing the genes result. Must have a source_id column.
  pValueCutoff:         the p-value exponent to use as a cutoff.  terms with a larger exponent are not returned
  outputFile:           the file in which to write results
  subOntologyName:      'Molecular Function' etc
  modelName:            eg, PlasmoDB.  Used to find the database connection.
  annotationSources:    a list of annotation sources in format compatible with an sql in clause. only include annotation that comes from these one or more sources.  (Eg, GeneDB, InterproScan).
  evidenceCodes:        a list of evidence codes in format compatible with an sql in clause. only include annotation that has one of these evidence codes.

The gene result must only include genes from a single taxon.  It is an error otherwise.

The output file is tab-delimited, with these columns (sorted by e-value)
  - e-value
  - GO ID
  - number of genes in organism with this term
  - number of genes in result with this term
  - GO TERM

";

}
